#! /usr/bin/env node

/*
 *
 *  Copyright 2016-2017 Red Hat, Inc, and individual contributors.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

'use strict';

// Providing a title to the process in `ps`
process.title = 'nodeshift'; // Thanks Ember-cli :)

const fs = require('fs');
const yargs = require('yargs');
const log = require('../lib/common-log')();

/* eslint no-unused-expressions: "warn" */
yargs
  .version(require('../package.json').version)
  .usage('[--options]')
  .command(['deploy', '$0'], 'default command - deploy', { cmd: { default: 'deploy' } }, commandHandler)
  .command('build', 'build command', { cmd: { default: 'build' } }, commandHandler)
  .command('resource', 'resource command', { cmd: { default: 'resource' } }, commandHandler)
  .command('apply-resource', 'apply resource command', { cmd: { default: 'apply-resource' } }, commandHandler)
  .command('undeploy', 'undeploy resources', { cmd: { default: 'undeploy' } }, commandHandler)
  .option('projectLocation', {
    describe: 'change the default location of the project',
    type: 'string'
  })
  .option('configLocation', {
    describe: 'change the default location of the config',
    type: 'string'
  })
  .options('osc.strictSSL', {
    describe: 'setting to pass to the Openshift Rest Client. Set to false if using a self-sign cert'
  })
  .options('osl.tryServiceAccount', {
    describe: `setting to pass to the Openshift Config Loader. Set to false to by-pass service account lookup
    or use the KUBERNETES_AUTH_TRYSERVICEACCOUNT environment variable
    `
  })
  .options('nodeVersion', {
    describe: 'the version of Node.js to use for the deployed application.',
    alias: 'n',
    type: 'string',
    choices: ['latest', '9.x', '8.x', '7.x', '6.x', '5.x', '4.x'],
    default: 'latest'
  })
  .env('NODESHIFT')
  .option('quiet', {
    describe: 'supress INFO and TRACE lines from output logs',
    type: 'boolean'
  })
  .array('d')
  .option('build.recreate', {
    describe: 'flag to recreate a buildConfig or Imagestream',
    choices: ['buildConfig', 'imageStream', false, true],
    default: false
  })
  .options('build.forcePull', {
    describe: 'flag to make your BuildConfig always pull a new image from dockerhub or not',
    choices: [true, false],
    type: 'boolean',
    default: false
  })
  .options('metadata.out', {
    describe: 'determines what should be done with the response metadata from OpenShift',
    choices: ['stdout', 'ignore', '<filename>'],
    type: 'string',
    default: 'ignore'
  })
  .help().argv;

function commandHandler (argv) {
  const options = createOptions(argv);
  require('./cli')(options).then((response) => {
    if (options.metadata) {
      if (options.metadata.out === 'stdout') {
        process.stdout.write(JSON.stringify(response, null, 2));
      } else {
        fs.writeFileSync(options.metadata.out, JSON.stringify(response, null, 2), 'utf8');
      }
    } else {
      log.info('complete');
    }
  })
    .catch((err) => {
      log.error(err.message);
      log.error('Status code', err.statusCode);
      require('util').debuglog('nodeshift.cli')(err.stack);
      process.exit(1);
    });
}

function createOptions (argv) {
  const options = {};

  options.projectLocation = argv.projectLocation;
  options.configLocation = argv.configLocation;
  options.nodeVersion = argv.nodeVersion;
  process.env['NODESHIFT_QUIET'] = argv.quiet === true;
  options.metadata = argv.metadata;
  options.build = argv.build;
  options.cmd = argv.cmd;

  if (argv.osc) {
    options.osc = {
      strictSSL: argv.osc.strictSSL !== 'false'
    };
  }

  if (argv.osl) {
    options.osl = {
      tryServiceAccount: argv.osl.tryServiceAccount !== 'false'
    };
  }

  // Check for the -d array
  // If it is there, we need to parse it.
  // The values should be in the format VALUE=key
  if (argv.d) {
    const splitted = argv.d.map((props) => {
      return props.split('=');
    });

    // convert our split array to an array of objects where the key is the 0 index and value is the 1 index
    const definedProperties = splitted.map((v) => {
      return {
        key: v[0],
        value: v[1]
      };
    });

    options.definedProperties = definedProperties;
  } else {
    options.definedProperties = [];
  }

  return options;
}
